---
title: "R: Exploring Data"
author: "Alex Jack"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  powerpoint_presentation:
    reference_doc: '../../assets/powerpoint-styles/light-theme.pptx'

---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      eval = TRUE)
```


# Missing Values

```{r}
na_values <- c("NA", "NULL", "", " ")
data_gapminder <- read.csv(file.path("..", "..", "data", "gapminder_nas.csv"), na.strings = na_values)
# is.na()
```

:::notes
Missing values in R are coded as `NA`, a special value in R. When importing or tyding your data, it's important to ensure that you're properly identifying missing values, and handling them with the arguments `na.strings`, if using `read.csv()`, or `na`, if using `read_csv()`.

With the data loaded, we can investigate missing values. `is.na()` returns a logical vector, `TRUE` for `NA`, otherwise `FALSE`. This is easiest with a single vector...
:::

# Column names

```{r}
# get colnames
colnames(data_gapminder)

# generate logical vector
missing_pop <- is.na(data_gapminder$pop)
typeof(missing_pop)
head(missing_pop)
```

# Summarising data

```{r}
sum(missing_pop)

sum(is.na(data_gapminder$pop))
```

:::notes
The logical vector on it's own, is not super helpful. We can generate counts of the `TRUE` values by summing the number of `TRUE` instances in `missing_pop`...

We can do this more interactively with
:::

# Complete Cases

Another point of interest in looking at missing values is to explore the number of observations for which no data are missing, which can be done with `complete.cases()`. Similar to `is.na()`, `complete.cases()` returnds a logical vector...

```{r}
complete_gapminder <- complete.cases(data_gapminder)
typeof(complete_gapminder)
```

We can get a count, like before

```{r}
sum(complete_gapminder)
```


# Inspecting data

```{r}
# first few index numbers of comlpete cases
head(which(complete_gapminder))
```
:::notes
And for use later, when subsetting, we can also generate a vector of those which are complete, identified by  their index number. This is done with `which()`
:::

# Unique values

```{r}
unique(data_gapminder$continent)
```


# Duplicated values

```{r}
# on a vector
head(duplicated(data_gapminder$continent))

# there are 5 unique continents and 1699 duplicates
sum(duplicated(data_gapminder$continent))

# on a data frame
head(duplicated(data_gapminder))

# there are no duplicate values
sum(duplicated(data_gapminder))
```


:::notes
`duplicated()` returns a logical vector, `TRUE` for values (of a vector) or rows (of a data frame) that are duplicates, `FALSE` if they are unique. Since the first instance of a value is unique, the first value will return `FALSE`, and any subsequent duplicates will return `TRUE`.
:::

# Descriptive Statistics

:::notes 
Basic stats fucntions in R generally do not remove NA values by default, and if your data has NA values, they will return `NA`. You can avoid these errors with `na.rm = TRUE` as an argument.
:::

# Number of Observations

```{r}
length(data_gapminder$country)
length(data_gapminder) # will return ncol, but that's confusing
```
:::notes
When used on a data frame, however, `length()` returns the number of columns...
The number of values in a single vector can be derived with `length()`
:::


When working with data frames, it is preferable to use `nrow()` and `ncol()` for the number of rows and columns, respectively.

```{r}
ncol(data_gapminder)
nrow(data_gapminder)
```

# Range

```{r}
range(data_gapminder$year, na.rm = TRUE)
```

:::notes
The range of your data can be calculated with `range()`.
:::

# Min and max

```{r}
min(data_gapminder$year, na.rm = TRUE)
max(data_gapminder$year, na.rm = TRUE)
```


### Mean & Median

The mean and median are calculated with `mean()` and `median()` respectively...

```{r}
mean(data_gapminder$lifeExp, na.rm = TRUE)
median(data_gapminder$gdpPercap, na.rm = TRUE)
```
:::notes
If you're only interested in the min or max values individually, this can be pulled with `min()` and `max()` respectively.
:::

### Variance and Standard Deviation

```{r}
var(data_gapminder$lifeExp, na.rm = TRUE)
sd(data_gapminder$lifeExp, na.rm = TRUE)
```

:::notes
The variance and SD are calculated with `var()` and `sd()`...
:::

# Quantiles


```{r}
quantile(data_gapminder$gdpPercap, na.rm = TRUE)
```

:::notes
Quantiles can be derived with `quantile()`, which defaults to the max, min and interquartiles.
:::


# Summaries


```{r}
summary(data_gapminder$gdpPercap)
summary(data_gapminder)
```
:::notes
Much of the above can be gathered all at once if needed with `summary()`. `summary()` can be run on a single vector, or on an entire data frame...
:::

# Proper summary

```{r, echo = FALSE}
data_gapminder[1:3] <- lapply(data_gapminder[1:3], function(x) as.factor(x))
```
:::notes
A better summary would come from properly denoted data types...
:::

```{r}
# summary with the first three columns classed as categorical data
summary(data_gapminder)
```

# Visualizing Distributions

```{r echo = FALSE, eval = TRUE}
hist(data_gapminder$gdpPercap)
```

:::notes
Plotting for presentation will be covered in greater detail in a future session.
Basic plotting for distribution analysis is relatively straight forward in base R.
:::

# Histograms

```{r}
hist(data_gapminder$gdpPercap)
# increase number of buckers
hist(data_gapminder$gdpPercap, breaks = 30)
```
:::notes
You can plot a basic histogram with `hist()`
And you can increase the 'buckets' with the `breaks` argument
:::

# Density Plots

```{r}
dens <- density(data_gapminder$lifeExp, na.rm = TRUE)
plot(dens)
```
:::notes
A density plot can be generated with `plot()`, but requires the extra step of computing the density of the data with the `density()` function first
:::
# Distribution of Two Variables

```{r echo = FALSE, eval=TRUE}
boxplot(data_gapminder$lifeExp ~ data_gapminder$continent)
```

# Box Plots

```{r}
boxplot(data_gapminder$lifeExp ~ data_gapminder$continent)
```
:::notes
`boxplot()` allows you to facet one variable by another using a tilde `~` to define the relationship
:::

# Scatter Plots

```{r}
plot(x = data_gapminder$gdpPercap, y = data_gapminder$lifeExp)
```
:::notes

`plot()` by default assumes a single variable as in the earlier example, but will generate a scatter plot if provided with two variables, the first assigned to the x-axis, the second to the y-axis.
:::

# Data transformations for better visualisation

```{r}
# log transform gdp per capita
plot(x = log(data_gapminder$gdpPercap), y = data_gapminder$lifeExp)
```

:::notes
You can also transform you data within the function for quick investigation
:::









