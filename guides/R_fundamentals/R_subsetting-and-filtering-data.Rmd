---
title: 'R: Subsetting & Filtering Data'
author: "Alex Jack"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  powerpoint_presentation:
    reference_doc: '../../assets/powerpoint-styles/light-theme.pptx'
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      eval = TRUE)
library(skimr)
library(dplyr)
library(data.table)
```

# Base R

```{r}
data_gapminder <- read.csv("../../data/gapminder.csv")
lifeExp <- data_gapminder$lifeExp
head(lifeExp)
```

:::notes
We've already seen that we can select a single variable of a data frame with `$`.

It's important to note that generally R simplifies data structures when possible, so `lifeExp` has lost most of its attributes, and is now simply a vector...
:::

```{r, eval = FALSE, echo = FALSE}
class(lifeExp)
```

# Lists

```{r}
basic_list <- list(item_1 = letters,
     item_2 = 1:10,
     item_3 = c(TRUE, FALSE))

item_1 <- basic_list$item_1

item_1

# again, it defaults to creating a vector
class(item_1)
```
:::notes
`$` can be used with both data frames and lists.
:::

# `[` and `[[`

```{r}
pop_preserved <- data_gapminder["pop"]
pop_simple <- data_gapminder[["pop"]]

class(pop_preserved)
class(pop_simple)
```

:::notes

You can also subset using single or double square brackets. These provide you with more flexibility than `$`. They can also be more verbose. The primary difference between the two is that `[` preserves the original data structure, while `[[` discards it and simplifies.

`[` and `[[` allow you to specify specific ranges of columns and rows to extract. The arguments are passed as `[row range, column range]`. Leaving an argument blank returns all rows or columns.
:::

# Accessing rows and columns in data frames

```{r}
# value in the first row and first column
data_gapminder[1,1]

# values in the second row
data_gapminder[2,]
```

# Accessing multiple rows and columns at once

```{r}

# values in the first 5 rows and first 3 columns
data_gapminder[1:5, 1:3]
```

# Working with lists

```{r}
# return the first element of a list
basic_list[1]
# extract the first value from the first list item
basic_list[[1]][1]
```

:::notes
You can specify the row and column to subset either by its name, wrapped in "", or by its indexed number. However, if you want an item (value) from within a list, you need to simplify that object first with `[[` and then apply a single `[`.
:::

# Comparison & Logical Operators

You can also filter your data to specific cases based on conditions. This is done by placing the condition within the subsetting operators.

Conditions include:

| Operator   | Meaning
| --------:  | -------------------------------- |
| `!=`       | not equal to?                    |
| `==`       | equal to?                        |
| `<`        | less than                        |
| `>`        | greater than                     |
| `<=`       | less than or equal to            |
| `>=`       | equal to or greater than         |
| `!`        | not                              |
| `\|`       | or                               |
| `&`        | and                              |
| `%in%`     | in set (membership)              |

# Vectors

```{r}
# using the lifeExp vector created earlier
lifeExp_gt_70 <- lifeExp[lifeExp > 70]
head(lifeExp_gt_70, n = 20)
length(lifeExp_gt_70)
```

# Data Frames

For data frames, you identify the column and the condition for the values in that column, which will give you all rows that match that condition, followed by the columns of interest.

```{r}
# all columns for 1952
gapminder_1952 <- data_gapminder[data_gapminder$year == 1952, ]

head(gapminder_1952)

# country and gdp for 1952
gdp_1952 <- data_gapminder[data_gapminder$year == 1952, c(1,6)]

head(gdp_1952)
```

# `subset()`


```{r}
head(subset(data_gapminder, year == 1952), 1)
head(subset(data_gapminder, year == 1952,
            select = c("country", "gdpPercap")), 1)
```

:::notes
`subset()` allows you to achieve similar results to those above. At its most basic, it takes a data set and a condition on which to subset.
You can also list the columns you'd like to keep with the `select` argument.
:::

# Multiple conditions

```{r}
# 1952 and Americas
am_52 <- data_gapminder[data_gapminder$year == 1952 & data_gapminder$continent == "Americas", ]
head(am_52)

am_52_ss <- subset(data_gapminder, year == 1952 & continent == "Americas")
head(am_52_ss)
```

:::notes
Multiple conditions can be passed when subsetting, whether using `[` or `subset()`
:::

# Tidyverse

- The `dplyr` package 
- The `filter`, `select` operations

:::notes
from Tidyverse draws a good conceptual break between selecting variables and filtering for cases based on values with its `select()` and `filter()` functions.
:::

# `select()`


```{r, message = FALSE}
# load the library
library(dplyr)

# select 1 column
head(select(data_gapminder, country))

# select multiple columns
head(select(data_gapminder, year, lifeExp))

# select range of columns
head(select(data_gapminder, continent:pop))

# select numeric columns
head(select(data_gapminder, where(is.numeric)))

# select by negation
head(select(data_gapminder, !country))
```
:::notes
`select()` allows you pick columns based on their names. It takes two arguments, a data set, and a set of parameters by which to select columns; that parameter could be a single name, a span of names separated with a `:`, or some other condition, like names starting with, ending with, or containing specific characters, or even by the data type held in the column.
More options can be found here [https://dplyr.tidyverse.org/reference/select.html](https://dplyr.tidyverse.org/reference/select.html). 
:::

# `filter()`


```{r}
head(filter(data_gapminder, continent == "Americas"))
```

:::notes
`filter()` works well with other offerings from Tidyverse. And more options can be found here [https://dplyr.tidyverse.org/reference/filter.html](https://dplyr.tidyverse.org/reference/filter.html).

Filter is very similar to subset for working on data frames (it doesn't work on vectors), and follows the same basic approach of requiring a dataset and a condition on which to filter.
:::



# Filtering and mutating with `data.table`


```{r}
health_dt <- fread("../../data/health_data.csv") # load quickly with fread
health_dt[age >= 20, .(
  n = .N, # denotes
  mean_bmi_pre = mean(bmi_pre, na.rm = TRUE),
  mean_bmi_post = mean(bmi_post, na.rm = TRUE)
), by = group]
```

:::notes
The advantages of using data.table. `data.table` is fast...like really fast (built on `C` programming language). Expressive and logical `i`,`j`, `by` syntax. Does operations by reference meaning you don't have copies of big datasets floating around in your environment.
:::

# `data.table` logic

- `DT[i, j, by]`

- `i` operator is row-wise, like a filter statement (used above)

- `j` operator tells what to do and what to return

- `by` operator tells what to group by 

```{r}
health_dt[age >= 20, # `i` operator
          # `j` operator for what to do
          .(n = .N,
            mean_bmi_pre = mean(bmi_pre, na.rm = TRUE),
            mean_bmi_post = mean(bmi_post, na.rm = TRUE)
            ), by = group] # by operator tells what columns to group our j, i operation over
```



# Column operators with `data.table`

- `.SD` stands for subset data and is `data.table` shorthand for get all columns

```{r}
health_dt[, lapply(.SD, mean, na.rm = TRUE),
          by = smoker,
          .SDcols = !is.character] # notice ! operator
```
:::notes
`data.table` also plays well with **functional programming**. Truly can handle big datasets `fread` that would crash other base R reading funcitons. ! is.character tells data.table to operate mean on numeric columns only.
:::


# Subsetting column operations in `data.table` with `.SDcols 

```{r}
health_dt[, lapply(.SD, mean, na.rm = TRUE),
          by = smoker,
          .SDcols = c('weight_pre', 'weight_post')]

```
:::notes
We can also subset our `data.table` to specific columns by specifying a vector of col names we want to operate on.
:::


# Additional packages: `skimr`

```{r}
data_gapminder %>% select(country, lifeExp) %>% skim()
```

:::notes
:::